<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Opinionated Musings, mostly about software (probably)</title>
  <link href="https://blog.hughpowell.net/atom.xml" rel="self"/>
  <link href="https://blog.hughpowell.net"/>
  <updated>2024-01-15T11:09:48+00:00</updated>
  <id>https://blog.hughpowell.net</id>
  <author>
    <name>Hugh Powell</name>
  </author>
  <entry>
    <id>https://blog.hughpowell.net/modern-software-engineering-for-a-small-team.html</id>
    <link href="https://blog.hughpowell.net/modern-software-engineering-for-a-small-team.html"/>
    <title>Modern software engineering for a small team</title>
    <updated>2024-01-16T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<h1 id="why,&#95;oh&#95;why,&#95;oh&#95;why?">Why, oh why, oh why?</h1><p>I'm a software engineer with two decades in the software industry. Over those two decades I've spent most of my time in "brown field" code bases, code bases where I wasn't around when they were first started. I've also been working inside larger ecosystems that provide a lot, if not all, of the surrounding infrastructure (e.g. integration and deployment pipelines, databases, logging, etc.). This means that I rarely spin up new projects, nor do I understand the fundamentals that underpin the tooling that is required to support those products. That tooling is abstracted away and my use of it is reduced to an API call or copy, paste and small modification of a config file. This is great for working in that particular ecosystem, but doesn't help me understand what is going on under the hood. While this understanding clearly isn't a requirement to do my job (or I'm doing fantastically well to "faking it until I make it") it's gotten to the point where I really would like to understand what is required and what is going on.</p><p>To explore these cracks (or more likely crevasse's in my understanding) my plan is to work through a project from scratch using what I believe to be modern software engineering techniques and processes as if I were bootstrapping a new product with a small team. I hope to take the simplest (not always the easiest) route possible and eschewing certain technologies until their introduction reduces the complexity of the product. Off the top of my head I'm hoping to get away without needing Terraform or Kubernetes and while I intend to use the cloud I'm hoping to steer clear of the big cloud computing platforms (AWS, GCP, Azure) and rely on cloud VMs capable of running docker containers.</p><p>A lot of my recent thinking about software engineering is underpinned by <a href='https://itrevolution.com/product/accelerate/'>Accelerate</a> by Nicole Forsgren, Jez Humble and Gene Kim. I expect I will often refer to the capabilities described there during this series of blog posts.</p><p>My years of labor have also exposed me to many ideas that would like to try, but which I haven't found space to try them out in a professional setting. </p><h1 id="so&#95;what's&#95;the&#95;product?">So what's the product?</h1><p>Normally when I'm trying out new languages, processes and/or tools I'll build the requisite contacts or todo-list application. The problem with those projects specifically is that the vast majority of the code ends up being request and response handling, authentication, database wrangling and the like. There's very little actual business logic. Hopefully this product will be evolved over time and my experience is that while the aforementioned is a requisite for most products it's the business logic that evolves. I've just started reading Mark Seemann's book <a href='https://www.oreilly.com/library/view/code-that-fits/9780137464302/'>Code That Fits in Your Head</a> which apparently includes a restaurant reservation system that he builds throughout the book, starting simply and modifying and adding new features as new use cases present themselves. Exactly the sort of product I'm looking for.</p><h1 id="presumably&#95;there's&#95;a&#95;plan?">Presumably there's a plan?</h1><p>The example application in Code That Fits in Your Head is written in C#. My current tool of choice is <a href='https://clojure.org/'>Clojure</a> so as I read through each chapter I will build a Clojure application using the requirements defined in that chapter. While the code for this blog series will be in Clojure I hope to explore some wider software engineering thoughts and opinions I have. Hopefully this means this series will be useful to more than just Clojurists. Also, this isn't a beginners guide to Clojure. If you're new to Clojure and need some resources to get started then <a href='https://practical.li/clojure/'>Practicalli</a>, the <a href='https://clojure.org/guides/getting_started'>Getting Started section of the Clojure website</a> and <a href='http://www.braveclojure.com/'>Clojure for the Brave and True</a> are all excellent starting points. I imagine I will be experimenting with some new tools and libraries and making plenty of mistakes which I will then rectify later in the series.</p><h1 id="check&#95;it&#95;out">Check it out</h1><p>The first practical advice in Code That Fits in Your Head provides is to use checklists. Having read Atul Gawande's <a href='http://atulgawande.com/book/the-checklist-manifesto/'>The Checklist Manifesto</a> and agreed with most of it, I'm all on board for this. The book recommends the following checklist for starting a project</p><ul><li>[ ] Use Git</li><li>[ ] Automate the build</li><li>[ ] Turn on all error messages</li></ul><p>A checklist isn't a detailed list of everything that needs to be done, nor is it a list of requirements. It's just a reminder of the high level, important things that need to be done. Neither is it static, checklists are expected to be personalised and evolved over time. This seems like as good a starting point as any.</p><h1 id="first&#95;things&#95;first">First things first</h1><p>Code That Fits in Your Head starts off by creating a web server that simply returns "Hello World!" to every request, so that's where I'll start.</p><h2 id="project&#95;management">Project management</h2><p>Of the 3 main project management tools available for Clojure, (<a href='https://clojure.org/guides/deps_and_cli'>deps.edn</a>, <a href='https://leiningen.org/'>leiningen</a> and <a href='https://boot-clj.github.io/'>boot</a>) the most I've had experience with recently is deps.edn, so I'll go with that. Sean Corfield's <a href='https://github.com/seancorfield/deps-new'>deps-new</a> is one option for generating projects from templates, but in this instance I'm going to do it by hand.</p><h2 id="a&#95;minimal&#95;web&#95;server">A minimal web server</h2><p>To start with I'll need a minimal directory layout</p><pre><code class="lang-shell">restaurant/
├── deps.edn
├── src
│   └── restaurant.clj
</code></pre><p>There are two primary mechanisms for server side applications in Clojure, <a href='https://github.com/ring-clojure/ring'>ring</a> and <a href='https://github.com/pedestal/pedestal'>pedestal</a>. I haven't used pedestal in anger and the ring ecosystem is rich and vibrant so that's the one I'll be working with. With that in mind, I'll create our <code>deps.edn</code> file with the following dependencies.</p><pre><code class="lang-clojure">{:paths &#91;&quot;src&quot;&#93;
 :deps {org.clojure/clojure {:mvn/version &quot;1.11.1&quot;}
        ring/ring-jetty-adapter {:mvn/version &quot;1.11.0&quot;}}}
</code></pre><p>As mentioned above, the current requirement is for a web server that simply returns "Hello World!" as the response to any requests. The easiest way to do this is as follows</p><pre><code class="lang-clojure">&#40;ns restaurant
  &#40;:require &#91;ring.adapter.jetty :as jetty&#93;&#41;
  &#40;:gen-class&#41;&#41;

&#40;defn -main &#91;&amp; &#95;args&#93; &#40;jetty/run-jetty &#40;fn &#91;&#95;&#93; {:status 200 :body &quot;Hello World!&quot;}&#41;&#41;&#41;
</code></pre><p>While this code will work in production (once I've built and deployed the service) I can't run it locally as a normal user, either in the REPL or on the command line, because it will attempt to bind to port 80. Assuming I'm not running anything else on port 80, I can escalate my privileges and check that it works. On my linux box that's</p><pre><code class="lang-shell">$ sudo clojure -M -m restaurant
</code></pre><p>and I can then access the server using curl (or your command line web client of choice).</p><pre><code class="lang-shell">$ curl localhost
Hello World!
</code></pre><p>Although it works, this is a pretty hostile situation for a developer, especially as complexity increases.</p><h2 id="getting&#95;git'ty&#95;with&#95;it">Getting Git'ty with it</h2><p>Now that I've got something working I check my checklist and the first thing I find is "Use Git". Cool,</p><ul><li>initialise our repository with Git</li><li>create an <a href='https://www.garfieldtech.com/blog/git-empty-commit'>initial, empty commit</a></li><li>create a <code>.gitignore</code> file and add in any files created by our IDE and anything else that we haven't explicitlycreated</li><li>stage the code and commit it</li></ul><h2 id="where'd&#95;my&#95;branch&#95;go?">Where'd my branch go?</h2><p>One of the capabilities outlined in Accelerate is "Trunk-based development". This means either working with very short-lived feature branches or no branches at all. Because I'll be the only person working on this product I intend to go with no branching at all. Once I start deploying to production I'll need some safeguards, but for now I'll commit straight to the trunk in as small commits as make sense.</p><h2 id="simplicity&#95;itself">Simplicity itself</h2><p>While the implementation of the server <i>technically</i> works, I tend to follow the mis-quoted aphorism that <a href='https://quoteinvestigator.com/2011/05/13/einstein-simple/'>"code should be as simple as possible, and no simpler"</a>. I actually think this code is too simple. It doesn't clean up after itself nor is it developer and REPL friendly. With that in mind I extract out <code>start-server</code> and <code>stop-server</code> functions and gracefully shut down the server when the service is shut down.</p><pre><code class="lang-clojure">&#40;ns restaurant
  &#40;:require &#91;ring.adapter.jetty :as jetty&#93;&#41;
  &#40;:import &#40;org.eclipse.jetty.server Server&#41;&#41;
  &#40;:gen-class&#41;&#41;

&#40;defn start-server
  &#40;&#91;&#93; &#40;start-server {}&#41;&#41;
  &#40;&#91;config&#93; &#40;jetty/run-jetty &#40;fn &#91;&#95;&#93; {:status 200 :body &quot;Hello World!&quot;}&#41; config&#41;&#41;&#41;

&#40;defn stop-server &#91;server&#93;
  &#40;.stop &#94;Server server&#41;&#41;

&#40;defn -main &#91;&amp; &#95;args&#93;
  &#40;let &#91;server &#40;start-server&#41;&#93;
    &#40;.addShutdownHook
      &#40;Runtime/getRuntime&#41;
      &#40;Thread. &#94;Runnable &#40;fn &#91;&#93; &#40;stop-server server&#41;&#41;&#41;&#41;&#41;&#41;

&#40;comment
  &#40;def server &#40;start-server {:port 3000 :join? false}&#41;&#41;
  &#40;stop-server server&#41;&#41;
</code></pre><p>By passing in config I can now use the default config for production and modify it simply at development time. Here I run the server on port 3000 and setting <code>:join?</code> to <code>false</code> means the server doesn't block our REPL thread.</p><h2 id="what's&#95;that&#95;noise?">What's that noise?</h2><p>Great. I can now start and stop our web server in the REPL, a much friendlier developer experience. The only problem is that when I do start the application/REPL I get the following warning</p><pre><code class="lang-shell">SLF4J: No SLF4J providers were found.
SLF4J: Defaulting to no-operation &#40;NOP&#41; logger implementation
SLF4J: See https://www.slf4j.org/codes.html#noProviders for further details.
</code></pre><p>Looks like our server uses SLF4J for logging, so I should provide a logger implementation. I could use the no-op logger, but I tend to like being informed when stuff goes wrong. With that in mind I use the SLF4J SimpleLogger by adding it to our dependencies</p><pre><code class="lang-clojure">{:paths   &#91;&quot;src&quot;&#93;
 :deps    {org.clojure/clojure {:mvn/version &quot;1.12.0-alpha5&quot;}
           org.slf4j/slf4j-simple {:mvn/version &quot;2.0.10&quot;}
           ring/ring-jetty-adapter {:mvn/version &quot;1.11.0&quot;}}}
</code></pre><p>Now when I start the application I no longer get the warning. Once I start the server, however, we get the following log messages</p><pre><code class="lang-shell">&#91;nREPL-session-aca1af76-ccda-46d5-b745-63e29dc26d52&#93; INFO org.eclipse.jetty.server.Server - jetty-11.0.18; built: 2023-10-27T02:14:36.036Z; git: 5a9a771a9fbcb9d36993630850f612581b78c13f; jvm 21.0.1+12-29
&#91;nREPL-session-aca1af76-ccda-46d5-b745-63e29dc26d52&#93; INFO org.eclipse.jetty.server.handler.ContextHandler - Started o.e.j.s.ServletContextHandler@cc0cd0{/,null,AVAILABLE}
&#91;nREPL-session-aca1af76-ccda-46d5-b745-63e29dc26d52&#93; INFO org.eclipse.jetty.server.AbstractConnector - Started ServerConnector@4ce608d3{HTTP/1.1, &#40;http/1.1&#41;}{0.0.0.0:3000}
&#91;nREPL-session-aca1af76-ccda-46d5-b745-63e29dc26d52&#93; INFO org.eclipse.jetty.server.Server - Started Server@36b520a7{STARTING}&#91;11.0.18,sto=0&#93; @23056ms
</code></pre><p>While this information can be useful in production unless I'm being warned about something I don't want this noisy  information distracting me during development. I still want to know about warnings and errors, so I just want to change the minimum logging level to <code>Warn</code>. There's a couple of ways to do that, but my preferred is to do it programmatically.</p><h2 id="introducing&#95;"dev"">Introducing "dev"</h2><p>Clojure has a concept of aliases to add or remove functionality depending on the situation. In this case, when I'm developing I want to set the minimum log level to <code>Warn</code>. I add an alias called <code>dev</code> to deps.edn</p><pre><code class="lang-clojure">{:paths   &#91;&quot;src&quot;&#93;
 :deps    {org.clojure/clojure {:mvn/version &quot;1.12.0-alpha5&quot;}
           org.slf4j/slf4j-simple {:mvn/version &quot;2.0.10&quot;}
           ring/ring-jetty-adapter {:mvn/version &quot;1.11.0&quot;}}
 :aliases {:dev {:extra-paths &#91;&quot;dev&quot;&#93;}}}
</code></pre><p>and a <code>dev/user.clj</code> file to our project</p><pre><code class="lang-shell">restaurant/
├── deps.edn
├── dev
│   └── user.clj
├── src
│   └── restaurant.clj
</code></pre><p>The <code>dev/user.clj</code> file will be loaded when the REPL starts, so I set the minimum log level in there</p><pre><code class="lang-clojure">&#40;ns user
  &#40;:import &#40;org.slf4j.simple SimpleLogger&#41;&#41;&#41;

&#40;System/setProperty SimpleLogger/DEFAULT&#95;LOG&#95;LEVEL&#95;KEY &quot;Warn&quot;&#41;
</code></pre><p>Now when I start the server from the REPL I no longer get the information log lines, leading to a cleaner development experience.</p><h1 id="summary">Summary</h1><p>In this first blog post I talked about why I'm creating this series, how it will (hopefully) demonstrate modern software development techniques and processes and I built a simple, first cut at a web server. In my next post I'll look at the second item on the checklist, "Automate the build". If you've got comments or questions feel free to reach out via Twitter/X (linked above) or on the Clojurians Slack channel.</p>]]></content>
  </entry>
</feed>
